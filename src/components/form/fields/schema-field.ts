import { LimeElementsAdapter } from '../adapter';
import JSONSchemaField from 'react-jsonschema-form/lib/components/fields/SchemaField';
import React from 'react';
import { FieldProps } from './types';
import { union, isEqual, isPlainObject } from 'lodash-es';
import { retrieveSchema } from 'react-jsonschema-form/lib/utils';

/**
 * Given a schema, detects if the schema wants to override the field component
 *
 * @param {object} schema a schema
 *
 * @returns {boolean} if the field is overriden
 */
const hasOverridenField = (schema): boolean => {
    return Boolean(schema.lime?.overrides?.field?.name);
};

/**
 * Given a schema, gets the overriden fields name and props
 * to pass to it
 *
 * @param {object} schema a schema
 *
 * @returns {{ name: string, props: object }} the name and props
 */
const getOverridenField = (
    schema
): { name: string; props: { [key: string]: any } } => {
    const name = schema.lime?.overrides?.field?.name;
    const props = schema.lime?.overrides?.field?.props || {};

    return { name: name, props: props };
};

const equals = (a, b) => a === b;

export class SchemaField extends React.Component<FieldProps> {
    constructor(props: FieldProps) {
        super(props);

        this.handleChange = this.handleChange.bind(this);
        this.detectDependencyAffectingChanges = this.detectDependencyAffectingChanges.bind(
            this
        );
    }

    handleChange(event) {
        event.stopPropagation();

        this.detectDependencyAffectingChanges(event.detail);
    }

    /**
     * Given the data for the current SchemaField, detect if the changed data
     * has any other fields that are dependent on it, and if so reset those dependent fields
     * (by deleting them from the data so that their defaults are populated on the next rerender).
     * Call onChange with the updated data
     *
     * @param {any} data The form data from a change event
     *
     * @returns {void}
     */
    detectDependencyAffectingChanges(data) {
        const {
            formData,
            schema,
            registry: { definitions },
            onChange,
        } = this.props;

        // Dependencies only exist on object types
        if (isPlainObject(data)) {
            // Get the schema generated by the current data
            const currentSchema =
                '$ref' in schema
                    ? retrieveSchema(schema, definitions, formData)
                    : schema;

            // Get the new schema that is calculated for the new data
            const newSchema =
                '$ref' in schema
                    ? retrieveSchema(schema, definitions, data)
                    : schema;

            // Get property keys whose schema changed due to the new data.
            // These properties that have changed are the properties that are dependent on
            // data that has changed in the current onChange event
            const dependentPropertyKeys = this.getDifferentKeys(
                newSchema.properties,
                currentSchema.properties,
                isEqual
            );

            // Reset keys that are dependent on the changed value
            // the values for these dependent fields will be repopulated
            // with defaults during the next render
            for (const dependentPropertyKey of dependentPropertyKeys) {
                delete data[dependentPropertyKey];
            }
        }

        onChange(data);
    }

    /**
     * Given two objects, get a list of keys for each value that is different between
     * the two objects
     *
     * @param {object} a first object
     * @param {object} b second object
     * @param {any} equalsFunc A function to compare values. Defaults to ===
     *
     * @returns {any[]} the array of keys
     */
    getDifferentKeys(a: object, b: object, equalsFunc = equals): any[] {
        const keys = union(Object.keys(a), Object.keys(b));
        return keys.filter(key => {
            return !equalsFunc(b[key], a[key]);
        });
    }

    render() {
        const fieldProps = {
            ...this.props,
            onChange: this.detectDependencyAffectingChanges,
        };

        // Check if the field component has been overriden in the schema
        if (hasOverridenField(this.props.schema)) {
            // Get the overriden field and props
            const { name, props: overridenFieldProps } = getOverridenField(
                this.props.schema
            );

            // Render the overriden field web component
            return React.createElement(LimeElementsAdapter, {
                name: name,
                elementProps: {
                    fieldProps: fieldProps,
                    ...overridenFieldProps,
                },
                events: {
                    change: this.handleChange,
                },
            });
        }

        return React.createElement(JSONSchemaField, fieldProps);
    }
}
